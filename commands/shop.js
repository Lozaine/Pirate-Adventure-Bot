const { SlashCommandBuilder, EmbedBuilder, ActionRowBuilder, StringSelectMenuBuilder, ButtonBuilder, ButtonStyle } = require('discord.js');
const database = require('../database/postgresDatabase.js');
const config = require('../config.js');
const economySystem = require('../systems/economySystem.js');
const items = require('../data/items.js');

module.exports = {
    data: new SlashCommandBuilder()
        .setName('shop')
        .setDescription('Visit the merchant shop to buy items and equipment')
        .addSubcommand(subcommand =>
            subcommand
                .setName('browse')
                .setDescription('Browse available items in the shop')
        )
        .addSubcommand(subcommand =>
            subcommand
                .setName('buy')
                .setDescription('Buy an item from the shop')
                .addStringOption(option =>
                    option.setName('item')
                        .setDescription('The item you want to buy')
                        .setRequired(true)
                        .setAutocomplete(true)
                )
        )
        .addSubcommand(subcommand =>
            subcommand
                .setName('sell')
                .setDescription('Sell items from your inventory')
                .addStringOption(option =>
                    option.setName('item')
                        .setDescription('The item you want to sell')
                        .setRequired(true)
                        .setAutocomplete(true)
                )
        )
        .addSubcommand(subcommand =>
            subcommand
                .setName('inventory')
                .setDescription('View your current inventory')
        ),
        
    async execute(interaction) {
        const userId = interaction.user.id;
        const userData = await database.getUser(userId);
        
        if (!userData) {
            const embed = new EmbedBuilder()
                .setColor(config.COLORS.ERROR)
                .setTitle('‚ùå Not Registered')
                .setDescription('You need to register first! Use `/register` to begin your pirate adventure.');
            return await interaction.reply({ embeds: [embed] });
        }
        
        const subcommand = interaction.options.getSubcommand();
        
        switch (subcommand) {
            case 'browse':
                await handleBrowse(interaction, userData);
                break;
            case 'buy':
                await handleBuy(interaction, userData);
                break;
            case 'sell':
                await handleSell(interaction, userData);
                break;
            case 'inventory':
                await handleInventory(interaction, userData);
                break;
        }
    },
    
    async autocomplete(interaction) {
        const focusedValue = interaction.options.getFocused();
        const subcommand = interaction.options.getSubcommand();
        const userId = interaction.user.id;
        const userData = await database.getUser(userId);
        
        if (subcommand === 'buy') {
            const shopItems = economySystem.getShopItems();
            const filtered = shopItems.filter(item => 
                item.name.toLowerCase().includes(focusedValue.toLowerCase())
            ).slice(0, 25);
            
            await interaction.respond(
                filtered.map(item => ({
                    name: `${item.name} - ‚Çø${item.price.toLocaleString()}`,
                    value: item.id
                }))
            );
        } else if (subcommand === 'sell' && userData) {
            const userItems = userData.inventory || [];
            const filtered = userItems.filter(item => 
                item.name.toLowerCase().includes(focusedValue.toLowerCase())
            ).slice(0, 25);
            
            await interaction.respond(
                filtered.map(item => ({
                    name: `${item.name} (${item.quantity}) - ‚Çø${Math.floor(item.sellPrice || item.price * 0.6)}`,
                    value: item.id
                }))
            );
        }
    }
};

async function handleBrowse(interaction, userData) {
    const currentPage = 0; // Start with first category
    // Ensure berries field exists and has a valid value
    const berries = userData.berries || 0;
    const embed = createCategorizedShopEmbed(currentPage, berries);
    
    // Create navigation buttons - we have multiple categories
    const totalCategories = getShopCategories().length;
    let components = [];
    if (totalCategories > 1) {
        const row = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId(`shop_page_${Math.max(0, currentPage - 1)}`)
                    .setLabel('‚óÄÔ∏è Previous')
                    .setStyle(ButtonStyle.Secondary)
                    .setDisabled(currentPage === 0),
                new ButtonBuilder()
                    .setCustomId(`shop_page_${Math.min(totalCategories - 1, currentPage + 1)}`)
                    .setLabel('Next ‚ñ∂Ô∏è')
                    .setStyle(ButtonStyle.Secondary)
                    .setDisabled(currentPage === totalCategories - 1)
            );
        components.push(row);
    }
    
    await interaction.reply({ 
        embeds: [embed], 
        components: components 
    });
}

async function handleBuy(interaction, userData) {
    const itemId = interaction.options.getString('item');
    const item = economySystem.getShopItem(itemId);
    
    if (!item) {
        const embed = new EmbedBuilder()
            .setColor(config.COLORS.ERROR)
            .setTitle('‚ùå Item Not Found')
            .setDescription('The item you\'re looking for is not available in the shop.');
        return await interaction.reply({ embeds: [embed] });
    }
    
    // Ensure berries field exists and has a valid value
    const berries = userData.berries || 0;
    
    // Check if user has enough berries
    if (berries < item.price) {
        const embed = new EmbedBuilder()
            .setColor(config.COLORS.ERROR)
            .setTitle('üí∞ Insufficient Berries')
            .setDescription(`You don't have enough berries to buy **${item.name}**!`)
            .addFields(
                { name: 'üí∞ Price', value: `‚Çø${item.price.toLocaleString()}`, inline: true },
                { name: 'üí≥ Your Berries', value: `‚Çø${berries.toLocaleString()}`, inline: true },
                { name: '‚ùå Needed', value: `‚Çø${(item.price - berries).toLocaleString()}`, inline: true }
            );
        return await interaction.reply({ embeds: [embed] });
    }
    
    // Process purchase
    const purchaseResult = economySystem.buyItem(userData, item);
    
    if (purchaseResult.success) {
        // Update user data
        database.updateUser(interaction.user.id, purchaseResult.userData);
        
        const embed = new EmbedBuilder()
            .setColor(config.COLORS.SUCCESS)
            .setTitle('‚úÖ Purchase Successful!')
            .setDescription(`You successfully bought **${item.name}**!`)
            .addFields(
                { name: 'üõí Item', value: item.name, inline: true },
                { name: 'üí∞ Price', value: `‚Çø${item.price.toLocaleString()}`, inline: true },
                { name: 'üí≥ Remaining Berries', value: `‚Çø${(purchaseResult.userData.berries || 0).toLocaleString()}`, inline: true },
                { name: 'üì¶ Description', value: item.description }
            );
            
        // Add stat bonuses if it's equipment
        if (item.type === 'equipment' && item.stats) {
            let statText = '';
            if (item.stats.attack > 0) statText += `+${item.stats.attack} Attack\n`;
            if (item.stats.defense > 0) statText += `+${item.stats.defense} Defense\n`;
            if (item.stats.health > 0) statText += `+${item.stats.health} Health\n`;
            
            if (statText) {
                embed.addFields({ name: 'üìà Stat Bonuses', value: statText });
            }
        }
        
        await interaction.reply({ embeds: [embed] });
    } else {
        const embed = new EmbedBuilder()
            .setColor(config.COLORS.ERROR)
            .setTitle('‚ùå Purchase Failed')
            .setDescription(purchaseResult.error || 'Unable to complete the purchase.');
        await interaction.reply({ embeds: [embed] });
    }
}

async function handleSell(interaction, userData) {
    const itemId = interaction.options.getString('item');
    
    // Find item in user's inventory
    const inventoryItem = userData.inventory.find(item => item.id === itemId);
    
    if (!inventoryItem) {
        const embed = new EmbedBuilder()
            .setColor(config.COLORS.ERROR)
            .setTitle('‚ùå Item Not Found')
            .setDescription('You don\'t have that item in your inventory.');
        return await interaction.reply({ embeds: [embed] });
    }
    
    // Process sale
    const sellResult = economySystem.sellItem(userData, inventoryItem);
    
    if (sellResult.success) {
        // Update user data
        database.updateUser(interaction.user.id, sellResult.userData);
        
        const embed = new EmbedBuilder()
            .setColor(config.COLORS.SUCCESS)
            .setTitle('üí∞ Item Sold!')
            .setDescription(`You sold **${inventoryItem.name}** successfully!`)
            .addFields(
                { name: 'üõí Item', value: inventoryItem.name, inline: true },
                { name: 'üí∞ Sale Price', value: `‚Çø${sellResult.sellPrice.toLocaleString()}`, inline: true },
                { name: 'üí≥ Total Berries', value: `‚Çø${(sellResult.userData.berries || 0).toLocaleString()}`, inline: true }
            );
            
        await interaction.reply({ embeds: [embed] });
    } else {
        const embed = new EmbedBuilder()
            .setColor(config.COLORS.ERROR)
            .setTitle('‚ùå Sale Failed')
            .setDescription(sellResult.error || 'Unable to sell the item.');
        await interaction.reply({ embeds: [embed] });
    }
}

async function handleInventory(interaction, userData) {
    const inventory = userData.inventory || [];
    
    if (inventory.length === 0) {
        const embed = new EmbedBuilder()
            .setColor(config.COLORS.WARNING)
            .setTitle('ÔøΩÔøΩ Empty Inventory')
            .setDescription('Your inventory is empty! Visit the shop to buy items.')
            .addFields(
                { name: 'üí∞ Your Berries', value: `‚Çø${(userData.berries || 0).toLocaleString()}` },
                { name: 'üõí Shop', value: 'Use `/shop browse` to see available items!' }
            );
        return await interaction.reply({ embeds: [embed] });
    }
    
    // Group items by type
    const groupedItems = inventory.reduce((groups, item) => {
        const type = item.type || 'misc';
        if (!groups[type]) groups[type] = [];
        groups[type].push(item);
        return groups;
    }, {});
    
    const embed = new EmbedBuilder()
        .setColor(config.COLORS.PRIMARY)
        .setTitle('üì¶ Your Inventory')
        .setDescription(`You have ${inventory.length} items in your inventory.`)
                    .addFields({ name: 'üí∞ Berries', value: `‚Çø${(userData.berries || 0).toLocaleString()}`, inline: true });
    
    // Add fields for each item type
    for (const [type, items] of Object.entries(groupedItems)) {
        const typeEmoji = {
            weapon: '‚öîÔ∏è',
            armor: 'üõ°Ô∏è',
            accessory: 'üíç',
            consumable: 'üß™',
            misc: 'üì¶'
        };
        
        const itemList = items.map(item => {
            const quantity = item.quantity > 1 ? ` (√ó${item.quantity})` : '';
            return `${item.name}${quantity}`;
        }).join('\n');
        
        embed.addFields({
            name: `${typeEmoji[type] || 'üì¶'} ${type.charAt(0).toUpperCase() + type.slice(1)}`,
            value: itemList || 'None',
            inline: true
        });
    }
    
    embed.setFooter({ text: 'Use /shop sell to sell items for berries!' });
    
    await interaction.reply({ embeds: [embed] });
}

function getShopCategories() {
    return [
        { key: 'accessory', name: 'üíç Accessories', description: 'Rings, bandanas, and special items that provide stat bonuses' },
        { key: 'weapon', name: '‚öîÔ∏è Weapons', description: 'Swords, cutlasses, and other combat weapons' },
        { key: 'armor', name: 'üõ°Ô∏è Armor', description: 'Protective gear including vests, coats, and suits' },
        { key: 'food', name: 'üçñ Food & Drink', description: 'Consumable items that provide healing and temporary buffs' },
        { key: 'consumable', name: 'üß™ Consumables', description: 'Single-use items with various effects' },
        { key: 'tool', name: 'üîß Tools', description: 'Navigation and utility items for exploration' },
        { key: 'material', name: 'üíé Materials', description: 'Rare materials and crafting components' }
    ];
}

function createCategorizedShopEmbed(categoryPage, userBerries) {
    const categories = getShopCategories();
    const currentCategory = categories[categoryPage];
    const shopItems = economySystem.getShopItems();
    
    // Get items for current category
    const categoryItems = shopItems.filter(item => {
        const itemType = item.type || 'material';
        return itemType === currentCategory.key;
    });
    
    const embed = new EmbedBuilder()
        .setColor(config.COLORS.PRIMARY)
        .setTitle(`üè™ ${currentCategory.name}`)
        .setDescription(currentCategory.description)
        .addFields({ name: 'üí∞ Your Berries', value: `‚Çø${userBerries.toLocaleString()}`, inline: true });
    
    if (categoryItems.length === 0) {
        embed.addFields({
            name: 'üì¶ No Items Available',
            value: 'This category is currently empty. Check back later!',
            inline: false
        });
    } else {
        // Add each item with full details
        categoryItems.forEach(item => {
            const affordable = userBerries >= item.price ? '‚úÖ' : '‚ùå';
            let itemValue = `**‚Çø${item.price.toLocaleString()}**\n${item.description}`;
            
            // Add stat bonuses if available
            if (item.stats) {
                let statText = '';
                if (item.stats.attack > 0) statText += `+${item.stats.attack} Attack `;
                if (item.stats.defense > 0) statText += `+${item.stats.defense} Defense `;
                if (item.stats.health > 0) statText += `+${item.stats.health} Health `;
                if (statText) itemValue += `\nüìà ${statText.trim()}`;
            }
            
            // Add food effects if available
            if (item.effects) {
                let effectText = '';
                if (item.effects.heal) effectText += `+${item.effects.heal} HP `;
                if (item.effects.attack) effectText += `+${item.effects.attack} ATK `;
                if (item.effects.defense) effectText += `+${item.effects.defense} DEF `;
                if (effectText && item.duration) {
                    const duration = Math.floor(item.duration / 60000);
                    effectText += `(${duration}min)`;
                }
                if (effectText) itemValue += `\nüéä ${effectText.trim()}`;
            }
            
            // Add special properties
            if (item.special) {
                itemValue += `\n‚ú® ${item.special}`;
            }
            
            // Add rarity indicator
            const rarityEmojis = {
                'common': '‚ö™',
                'uncommon': 'üü¢', 
                'rare': 'üîµ',
                'epic': 'üü£',
                'legendary': 'üü°'
            };
            const rarityEmoji = rarityEmojis[item.rarity] || '‚ö™';
            
            embed.addFields({
                name: `${affordable} ${rarityEmoji} ${item.name}`,
                value: itemValue,
                inline: false
            });
        });
    }
    
    embed.setFooter({ 
        text: `Page ${categoryPage + 1}/${categories.length} ‚Ä¢ Use /shop buy <item> to purchase`
    });
    
    return embed;
}

function getItemTypeIcon(type) {
    const icons = {
        'weapon': '‚öîÔ∏è',
        'armor': 'üõ°Ô∏è', 
        'accessory': 'üíç',
        'food': 'üçñ',
        'consumable': 'üß™',
        'tool': 'üîß',
        'material': 'üíé'
    };
    return icons[type] || 'üì¶';
}
